__global__ void spmv_csr_warp( int rows, const int *row_ptr, 
                               const int *col_idx, const float *val,
                               const float *x, float *y ){
  int warp_id = (blockIdx.x * blockDim.x + threadIdx.x) >> 5; // warp index
  int lane = threadIdx.x & 31;
  if(warp_id >= rows) return;
  int row_start = row_ptr[warp_id], row_end = row_ptr[warp_id+1];
  float sum = 0.0f;
  // each lane processes a strided subset of nonzeros in the row
  for(int idx = row_start + lane; idx < row_end; idx += 32){
    int c = col_idx[idx];           // column index
    float v = val[idx];            // nonzero value
    sum += v * x[c];               // multiply-add
  }
  // warp-wide reduction using shuffle XOR
  for(int offset=16; offset>0; offset>>=1) sum += __shfl_xor_sync(0xffffffff, sum, offset);
  if(lane==0) y[warp_id] = sum;    // write result
}